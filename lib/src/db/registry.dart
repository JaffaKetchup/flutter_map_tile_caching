import 'dart:io';

import 'package:flutter/foundation.dart';
import 'package:isar/isar.dart';
import 'package:meta/meta.dart';

import '../fmtc.dart';
import 'defs/store.dart';
import 'defs/tile.dart';

/// Manages the tile stores available
///
/// The registry database contains a list of [DbStore]s, which as well as
/// containing some metadata, have an ID generated by the store name, which
/// refers to the independent database file of the same name, which contains
/// tiles.
///
/// It is very important for the registry to remain in sync with the actual state
/// of the root directory ([_directory]), otherwise data loss can easily occur.
/// See [synchronise]'s documentation for more information.
@internal
class FMTCRegistry {
  final String _directory;

  final Isar registryDatabase;
  final Map<int, Isar> tileDatabases = {};

  FMTCRegistry._(this._directory, this.registryDatabase);
  static late FMTCRegistry instance;

  static Future<FMTCRegistry> initialise({
    Directory? dirReal,
    String? dirString,
  }) async {
    if (dirReal == null && dirString == null) {
      throw ArgumentError('Either `dirReal` or `dirString` should be provided');
    }

    final String directory = dirString ?? dirReal!.absolute.path;

    instance = FMTCRegistry._(
      directory,
      await Isar.open(
        [DbStoreSchema, if (kDebugMode) DbTileSchema],
        name: 'registry',
        directory: directory,
      ),
    );
    await instance.synchronise();

    return instance;
  }

  Future<void> uninitialise({bool delete = false}) async {
    await synchronise();
    await Future.wait<void>([
      ...tileDatabases.entries.map((e) async {
        await e.value.close(deleteFromDisk: delete);
        tileDatabases.remove(e.key);
      }),
      registryDatabase.close(deleteFromDisk: delete),
    ]);
  }

  /// Synchronise the contents of the registry with the contents of the root
  /// directory
  ///
  /// To manage a store, see [StoreManagement]. Those methods change the state of
  /// the registry, then call this method to synchronise.
  ///
  /// Note that calling this method can lead to data loss - a tile store without
  /// a corresponding registry entry will be deleted without warning.
  Future<void> synchronise() async => Future.wait<void>([
        ...tileDatabases.entries.map((e) async {
          if (await registryDatabase.stores.get(e.key) == null) {
            tileDatabases.remove(e.key);
            if (e.value.isOpen) await e.value.close(deleteFromDisk: true);
          }
        }),
        ...(await registryDatabase.stores.where().findAll()).map((s) async {
          if (!tileDatabases.containsKey(s.id)) {
            tileDatabases[s.id] = await Isar.open(
              [DbTileSchema],
              name: s.id.toString(),
              directory: _directory,
            );
          }
        }),
      ]);
}
